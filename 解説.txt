はじめに: 本レポートは、SuperCon2021における弊チーム「NPC」の回答プログラムの基本方針やアルゴリズムについて解説した文書である．
--------------------------------------------------------------------------

まず、問題文を見て、それぞれのマス目を頂点とし、それぞれの命令を辺としたグラフ問題に帰着することを考えた．
厳密には、各マス目を頂点とし任意の頂点からある一つの命令によって到達可能な頂点に、命令のindexを情報として持った有向辺を張ることで構築される有向グラフとする．

しかし、この方針で愚直に各頂点から命令をシミュレートしてグラフを構築すると、計算量は平均O(N^3×M)となり、非常に低速である．
そこで、命令を圧縮することを考えた．参考に入力生成器プログラムを見ると、出力される命令列において、同じ基本命令が十分に連続している．
連続している基本命令が実行可能か（途中で障害物に衝突しないか）は、あらかじめ二次元累積和を前計算しておくことでO(1)で判定することができるので、これらを利用することで平均計算量O(N^2 logN M)でグラフを構築することが可能となり、十分に高速である．

上記の方針によってグラフ問題に帰着した結果、問題文は以下のように言い換えることができ、以下、この問題を解くこととする．
「頂点数P(P <= N^2), 辺数Q(Q <= P*M)の有向グラフが与えられる．
任意の頂点から伸びる辺には、それぞれ異なる色k(1 <= k <= 2000)が付いている．
頂点0から辺を辿って指定された全ての頂点に辿り着けるグラフが存在するか判定し、
存在する場合は "YES" と出力、さらにそのうち最も使用する色の数が出来る限り少ないものを構築し、その色の組み合わせを出力せよ． 存在しない場合は "NO" と出力せよ．」
（ここで、指定された頂点とは、マス(1, 1)から基本命令を使ってたどり着けるマス(頂点)を指す．これはBFSを行うことで簡単に求めることができる．）

最初に、問われているグラフが存在するかの判定は、始点から全ての辺を使ってBFSを行い、辿り着ける頂点を調べることで判定できる．

次に、どうすれば使用する色数（命令数）をできるだけ少なくできるかについて考察する．
まず、グラフに閉路が存在する場合は、それよりも良い（使う色数が少ないか同じな）、閉路の存在しないグラフが存在することは自明である．よって、指定された全ての頂点における、頂点0を根とするいずれかの有向全域木を求めれば良いということが分かった．

近似解を求める解法として、始点から隣接する辺を貪欲に選んでいき、全域木を構築する方法を考えた．
具体的には、現在いる頂点に隣接する辺を候補に追加していき、そこから既に使ったことのある色の辺を優先してランダムに選び、それを指定された全ての頂点を訪れるまで繰り返す．
これを愚直に行うと計算量はO(Q)となるが、さらにBinary Indexed Treeの利用、差分更新などの工夫をすることで、平均計算量をおおよそO(P logM)に高速化することができた．

この操作を時間いっぱいまで繰り返し、最も色数が少なかったものを出力するプログラムとした．
（ここからビームサーチに発展させ、さらなる近似解を狙うことも考えたが、時間が足りなかったことや自分の知識不足などによって断念した．）
